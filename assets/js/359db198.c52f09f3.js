"use strict";(self.webpackChunkthe_open_source_with_remi=self.webpackChunkthe_open_source_with_remi||[]).push([[623,364],{7205:function(e,t,n){n.r(t),n.d(t,{Highlight:function(){return u},assets:function(){return m},contentTitle:function(){return p},default:function(){return k},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return c}});var a=n(3117),i=(n(7294),n(3905)),r=n(4996),l=n(6395);const o={id:"caramel91",title:"Caramel - Pipe operator support",sidebar_label:"9. Caramel - Pipe operator support"},p=void 0,s={unversionedId:"contributions/caramel91",id:"contributions/caramel91",title:"Caramel - Pipe operator support",description:"Erlang",source:"@site/docs/contributions/caramel#91.md",sourceDirName:"contributions",slug:"/contributions/caramel91",permalink:"/docs/contributions/caramel91",draft:!1,editUrl:"https://github.com/ayshiff/my-open-source-journey/docs/contributions/caramel#91.md",tags:[],version:"current",frontMatter:{id:"caramel91",title:"Caramel - Pipe operator support",sidebar_label:"9. Caramel - Pipe operator support"},sidebar:"docs",previous:{title:"8. Changesets - Comment on released PRs and issues",permalink:"/docs/contributions/changesets80"},next:{title:"10. Firefox for iOS - Bug fixing",permalink:"/docs/contributions/firefox-ios8327"}},m={},u=e=>{let{children:t,color:n}=e;return(0,i.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem",fontWeight:600}},t)},c=[{value:"Introduction",id:"introduction",level:2},{value:"Project",id:"project",level:3},{value:"Context",id:"context",level:3},{value:"Current behavior",id:"current-behavior",level:3},{value:"Implement the solution",id:"implement-the-solution",level:2},{value:"Caramel runtime",id:"caramel-runtime",level:3},{value:"Static single assignment",id:"static-single-assignment",level:3},{value:"Final result",id:"final-result",level:2},{value:"Takeaway",id:"takeaway",level:2},{value:"Problems encountered",id:"problems-encountered",level:3},{value:"What did I learn ?",id:"what-did-i-learn-",level:3}],d={Highlight:u,toc:c};function k(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"pr_infos"},(0,i.kt)("div",{className:"marginBottom"},(0,i.kt)("div",null,(0,i.kt)(l.Open,{date:"29 Mar 2021",mdxType:"Open"})),(0,i.kt)("span",{className:"badge badge--secondary marginRight"},"Erlang"),(0,i.kt)("span",{className:"badge badge--secondary marginRight"},"Elixir"),(0,i.kt)("span",{className:"badge badge--secondary marginRight"},"Compiler"),(0,i.kt)("span",{className:"badge badge--secondary marginRight"},"Ocaml"),(0,i.kt)("span",{className:"badge badge--secondary marginRight"},"functional-language"))),(0,i.kt)("admonition",{title:"Contribution link",type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/AbstractMachinesLab/caramel/pull/91"},"https://github.com/AbstractMachinesLab/caramel/pull/91"))),(0,i.kt)("admonition",{title:"Contribution Type",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This contribution is a new ",(0,i.kt)("strong",{parentName:"p"},"feature"),".")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("div",{className:"image-wrapper"},(0,i.kt)(l.ImageWrapper,{src:(0,r.Z)("img/caramel/cover.jpg"),width:"100%",alt:"Contribution presentation",mdxType:"ImageWrapper"}),(0,i.kt)("em",null,"Caramel pipe operator")),(0,i.kt)("h3",{id:"project"},"Project"),(0,i.kt)("p",null,"You can find the ",(0,i.kt)("strong",{parentName:"p"},"Caramel programming language presentation")," ",(0,i.kt)("a",{href:"/docs/projects/caramel"},(0,i.kt)(u,{color:"#203666",mdxType:"Highlight"},"here")),"."),(0,i.kt)("h3",{id:"context"},"Context"),(0,i.kt)("p",null,"This contribution adds pipe operator ",(0,i.kt)("inlineCode",{parentName:"p"},"|>")," support to the Caramel language.    "),(0,i.kt)("p",null,"Here is a summary of the different steps in a compiler:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Lexing")," the source into tokens"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Parsing")," the token stream into an AST (abstract syntax tree)"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Validating")," the AST"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Translating")," the AST")),(0,i.kt)("h3",{id:"current-behavior"},"Current behavior"),(0,i.kt)("p",null,'In many functional programming languages, it is a common way to compose functions into a readable left-to-right "pipeline" of steps of computation.'),(0,i.kt)("p",null,"For example in ",(0,i.kt)("a",{href:"https://ocaml.org/releases/4.11/htmlman/libref/Stdlib.html#VAL(%7C%3E)"},(0,i.kt)(u,{color:"#203666",mdxType:"Highlight"},"OCaml")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"val (|>) : 'a -> ('a -> 'b) -> 'b\n")),(0,i.kt)("admonition",{title:"Issue link",type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/AbstractMachinesLab/caramel/issues/72"},"https://github.com/AbstractMachinesLab/caramel/issues/72"))),(0,i.kt)("h2",{id:"implement-the-solution"},"Implement the solution"),(0,i.kt)("admonition",{title:"code blocks",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The code blocks are intentionally incomplete for the sake of readability.",(0,i.kt)("br",{parentName:"p"}),"\n","If you want to read the full code you'll find it in the PR link at the top.")),(0,i.kt)("admonition",{title:"changes",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"This PR being still Open, some parts are likely to change.",(0,i.kt)("br",{parentName:"p"}),"\n","I will keep the article updated if any changes are made.")),(0,i.kt)("h3",{id:"caramel-runtime"},"Caramel runtime"),(0,i.kt)("p",null,"The first idea was to expose the pipe operator as an external that maps to a ",(0,i.kt)("inlineCode",{parentName:"p"},"caramel_runtime:pipe")," function."),(0,i.kt)("p",null,"Here is the pipe operator signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml",metastring:'title="caramel/stdlib/caramel_runtime.ml"',title:'"caramel/stdlib/caramel_runtime.ml"'},"external ( |> ) : 'a -> ('a -> 'b) -> 'b = \"pipe\"\n")),(0,i.kt)("p",null,"Here is the pipe operator definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml",metastring:'title="caramel/stdlib/caramel_runtime.erl"',title:'"caramel/stdlib/caramel_runtime.erl"'},"pipe(A, B) -> B(A).\n")),(0,i.kt)("p",null,"We will tell the compiler to map ",(0,i.kt)("inlineCode",{parentName:"p"},"|>")," to our caramel_runtime pipe function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml",metastring:'title="caramel/compiler/ocaml_to_erlang/names.ml"',title:'"caramel/compiler/ocaml_to_erlang/names.ml"'},'let ocaml_to_erlang_primitive_op t =\n  match t with\n  (* ... *)\n  | "|>" ->\n      Name.qualified\n        ~m:(Name.atom (Atom.mk "caramel_runtime"))\n        ~f:(Name.atom (Atom.mk "pipe"))\n')),(0,i.kt)("p",null,"Finally given this input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'let print_int number = Io.format "~0tp~n" [ number ]\n\nlet subtract x y = y - x\nlet main _ =\n  let divide x y = y / x in\n  10 |> subtract 2 |> divide 4 |> print_int\n')),(0,i.kt)("p",null,"It will output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-erlang"},"-module(pipe).\n\n-export([main/1]).\n-export([print_int/1]).\n-export([subtract/2]).\n\n-spec print_int(_) -> ok.\nprint_int(Number) -> io:format(<<\"~0tp~n\">>, [Number | []]).\n\n-spec subtract(integer(), integer()) -> integer().\nsubtract(X, Y) -> erlang:'-'(Y, X).\n\n-spec main(_) -> ok.\nmain(_) ->\n  Divide = fun\n    (X, Y) -> erlang:'div'(Y, X)\n  end,\n  caramel_runtime:pipe(\n    caramel_runtime:pipe(\n      caramel_runtime:pipe(\n        10, subtract(2)\n      ),\n    Divide(4)\n  ),\nfun print_int/1).\n")),(0,i.kt)("p",null,"Look how the compiler has replaced our pipes."),(0,i.kt)("p",null,"The problem was that we needed to first implement partial application to make it work.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},"Partial application")," involves passing less than the full number of arguments to a function."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let add a b = a + b\nlet addOne = add 1\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"addOne")," is the result of partially applying ",(0,i.kt)("inlineCode",{parentName:"p"},"add"),".",(0,i.kt)("br",{parentName:"p"}),"\n","It is a function that takes an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and return ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," + 1."),(0,i.kt)("p",null,"In our example, ",(0,i.kt)("inlineCode",{parentName:"p"},"subtract")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Divide")," arr called with less arguments that they have to take."),(0,i.kt)("p",null,"So we went for another solution: rewrite the pipes into SSA (static single assignment)."),(0,i.kt)("h3",{id:"static-single-assignment"},"Static single assignment"),(0,i.kt)("p",null,"The translation phase is broken down into 3 phases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The AST is lowered into an ",(0,i.kt)("strong",{parentName:"li"},"IR")," (intermediate representation)"),(0,i.kt)("li",{parentName:"ul"},"The IR is ",(0,i.kt)("strong",{parentName:"li"},"analyzed")),(0,i.kt)("li",{parentName:"ul"},"The IR is ",(0,i.kt)("strong",{parentName:"li"},"translated"))),(0,i.kt)("p",null,"SSA introduces a new constraint: all variables are assigned exactly ",(0,i.kt)("strong",{parentName:"p"},"once"),"."),(0,i.kt)("p",null,"The idea is to go from this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let f x = x |> add 1 |> div 2 |> mult 3\n")),(0,i.kt)("p",null,"To something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"f(X) ->\n  Caramel@Tmp1 = add(1, X),\n  Caramel@Tmp2 = div(2, Caramel@Tmp1),\n  Caramel@Tmp3 = mult(3, Caramel@Tmp2).\n")),(0,i.kt)("p",null,"For now we will implement this logic in the ocaml translation side."),(0,i.kt)("p",null,"The goal is to go from ",(0,i.kt)("inlineCode",{parentName:"p"},"a |> f |> g")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"let a_f = f a in let a_f_g = g a_f"),"."),(0,i.kt)("p",null,"Inside ",(0,i.kt)("inlineCode",{parentName:"p"},"caramel/compiler/ocaml_to_erlang/fun.ml")," there is a match clause for the function application.",(0,i.kt)("br",{parentName:"p"}),"\n","We will add a special case for the pipe operator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"| Texp_apply (expr, args) ->\n    let name =\n      match\n        mk_expression expr ~var_names ~modules ~functions ~module_name\n      with\n      | Erlang.Ast.Expr_fun_ref { fref_name = n; _ } -> Expr.ident n\n      | x -> x\n    in\n    let args =\n      List.filter_map\n        (function\n          | _, None -> None\n          | _, Some arg ->\n              Some\n                (mk_expression arg ~var_names ~modules ~functions ~module_name))\n        args\n    in\n    Expr.apply name args\n")),(0,i.kt)("p",null,"The idea is to check if the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," variable is the pipe function and then do our logic to bind the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"f x")," to a new variable with a unique name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'if name = "<PIPE_OPERATOR>"\nthen (\n  let f = args[0] in\n  let x = args[1] in\n  let f_x = Expr.apply f x in\n  let new_var = "<NEW_VARIABLE_NAME>" in\n  let binding = Expr.bind new_var f_x in\n  Expr.var binding "<NEW_VARIABLE_NAME>"\n)\nelse (\n  Expr.apply name args\n)\n')),(0,i.kt)("h2",{id:"final-result"},"Final result"),(0,i.kt)("p",null,"The final result allows us to compose our function pipeline in this way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'"function1_arg_1"\n  |> function1 "function1_arg_2" \n  |> function2 "function2_arg_1" \n  |> function3\n')),(0,i.kt)("h2",{id:"takeaway"},"Takeaway"),(0,i.kt)("h3",{id:"problems-encountered"},"Problems encountered"),(0,i.kt)("p",null,"Understanding how the compiler works was the step that took me the most time.",(0,i.kt)("br",{parentName:"p"}),"\n","It required me to understand a codebase I'm not used to deal with."),(0,i.kt)("h3",{id:"what-did-i-learn-"},"What did I learn ?"),(0,i.kt)("p",null,"This contribution allowed me to review some concepts about ",(0,i.kt)("strong",{parentName:"p"},"compilers")," and ",(0,i.kt)("strong",{parentName:"p"},"functional")," programming languages."))}k.isMDXComponent=!0},6395:function(e,t,n){n.r(t),n.d(t,{ImageWrapper:function(){return d},Merged:function(){return c},Open:function(){return k},Status:function(){return g},assets:function(){return m},contentTitle:function(){return p},default:function(){return f},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return u}});var a=n(3117),i=n(7294),r=n(3905),l=n(2879);const o={},p=void 0,s={unversionedId:"utils",id:"utils",title:"utils",description:"",source:"@site/docs/utils.md",sourceDirName:".",slug:"/utils",permalink:"/docs/utils",draft:!1,editUrl:"https://github.com/ayshiff/my-open-source-journey/docs/utils.md",tags:[],version:"current",frontMatter:{}},m={},u=[],c=e=>{let{date:t}=e;return(0,r.kt)("div",null,(0,r.kt)("div",{className:"merged"},(0,r.kt)("span",null,(0,r.kt)("svg",{height:"16",viewBox:"0 0 16 16",version:"1.1",width:"16",fill:"white","aria-hidden":"true",className:"status_svg"},(0,r.kt)("path",{fillRule:"evenodd",d:"M5 3.254V3.25v.005a.75.75 0 110-.005v.004zm.45 1.9a2.25 2.25 0 10-1.95.218v5.256a2.25 2.25 0 101.5 0V7.123A5.735 5.735 0 009.25 9h1.378a2.251 2.251 0 100-1.5H9.25a4.25 4.25 0 01-3.8-2.346zM12.75 9a.75.75 0 100-1.5.75.75 0 000 1.5zm-8.5 4.5a.75.75 0 100-1.5.75.75 0 000 1.5z"})),"Merged")),t||null)},d=e=>{let{src:t,alt:n,width:a}=e;const[o,p]=i.useState(!1);return(0,r.kt)("div",null,(0,r.kt)("div",{className:"image-zoom",onClick:()=>p(!0)},(0,r.kt)("img",{src:t,alt:n,width:a})),o&&(0,r.kt)(l.Z,{mainSrc:t,onCloseRequest:()=>p(!1),mdxType:"Lightbox"}))},k=e=>{let{date:t}=e;return(0,r.kt)("div",null,(0,r.kt)("div",{className:"open"},(0,r.kt)("span",null,(0,r.kt)("svg",{height:"16",viewBox:"0 0 16 16",version:"1.1",width:"16",fill:"white","aria-hidden":"true",className:"status_svg"},(0,r.kt)("path",{fillRule:"evenodd",d:"M7.177 3.073L9.573.677A.25.25 0 0110 .854v4.792a.25.25 0 01-.427.177L7.177 3.427a.25.25 0 010-.354zM3.75 2.5a.75.75 0 100 1.5.75.75 0 000-1.5zm-2.25.75a2.25 2.25 0 113 2.122v5.256a2.251 2.251 0 11-1.5 0V5.372A2.25 2.25 0 011.5 3.25zM11 2.5h-1V4h1a1 1 0 011 1v5.628a2.251 2.251 0 101.5 0V5A2.5 2.5 0 0011 2.5zm1 10.25a.75.75 0 111.5 0 .75.75 0 01-1.5 0zM3.75 12a.75.75 0 100 1.5.75.75 0 000-1.5z"})),"Open")),t||null)},g=e=>{let{url:t}=e;const[n,a]=i.useState(null);return i.useEffect((()=>{let e=!0;return fetch(t).then((e=>e.json())).then((t=>{e&&a(t.merged)})),()=>{e=!1}}),[]),null===n?(0,r.kt)("div",null):!0===n?(0,r.kt)(c,{mdxType:"Merged"}):(0,r.kt)(k,{mdxType:"Open"})},h={toc:u,Merged:c,ImageWrapper:d,Open:k,Status:g};function f(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}))}f.isMDXComponent=!0}}]);