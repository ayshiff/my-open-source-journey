"use strict";(self.webpackChunkthe_open_source_with_remi=self.webpackChunkthe_open_source_with_remi||[]).push([[765,364],{1531:function(e,t,r){r.r(t),r.d(t,{Highlight:function(){return u},assets:function(){return p},contentTitle:function(){return d},default:function(){return m},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c}});var n=r(3117),s=(r(7294),r(3905)),a=r(4996),i=r(6395);const o={id:"apple-swift-nio1692",title:"SwiftNIO core - SocketAddress from packed bytes",sidebar_label:"1. SwiftNIO core - SocketAddress creation"},d=void 0,l={unversionedId:"contributions/apple-swift-nio1692",id:"contributions/apple-swift-nio1692",title:"SwiftNIO core - SocketAddress from packed bytes",description:"Swift",source:"@site/docs/contributions/apple-swift-nio#1692.md",sourceDirName:"contributions",slug:"/contributions/apple-swift-nio1692",permalink:"/docs/contributions/apple-swift-nio1692",draft:!1,editUrl:"https://github.com/ayshiff/my-open-source-journey/docs/contributions/apple-swift-nio#1692.md",tags:[],version:"current",frontMatter:{id:"apple-swift-nio1692",title:"SwiftNIO core - SocketAddress from packed bytes",sidebar_label:"1. SwiftNIO core - SocketAddress creation"},sidebar:"docs",previous:{title:"Concept presentation",permalink:"/docs/presentation"},next:{title:"2. xLayers - Rethink UX",permalink:"/docs/contributions/xlayers395"}},p={},u=e=>{let{children:t,color:r}=e;return(0,s.kt)("span",{style:{backgroundColor:r,borderRadius:"2px",color:"#fff",padding:"0.2rem",fontWeight:600}},t)},c=[{value:"Introduction",id:"introduction",level:2},{value:"Project",id:"project",level:3},{value:"Context",id:"context",level:3},{value:"Current behavior",id:"current-behavior",level:3},{value:"Implement the solution",id:"implement-the-solution",level:2},{value:"IPv4",id:"ipv4",level:3},{value:"IPv6",id:"ipv6",level:3},{value:"Create <code>SocketAddress</code> from packed byte representation",id:"create-socketaddress-from-packed-byte-representation",level:3},{value:"The <code>ByteBuffer</code>struct",id:"the-bytebufferstruct",level:4},{value:"Add a new <code>SocketAddressError</code>",id:"add-a-new-socketaddresserror",level:3},{value:"Add some tests",id:"add-some-tests",level:3},{value:"Takeaway",id:"takeaway",level:2},{value:"Problems encountered",id:"problems-encountered",level:3},{value:"What did I learn ?",id:"what-did-i-learn-",level:3}],k={Highlight:u,toc:c};function m(e){let{components:t,...r}=e;return(0,s.kt)("wrapper",(0,n.Z)({},k,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("div",{className:"pr_infos"},(0,s.kt)("div",{className:"marginBottom"},(0,s.kt)("div",null,(0,s.kt)(i.Merged,{date:"19 Nov 2020",mdxType:"Merged"})),(0,s.kt)("span",{className:"badge badge--secondary marginRight"},"Swift"),(0,s.kt)("span",{className:"badge badge--secondary marginRight"},"protocol servers & clients"))),(0,s.kt)("admonition",{title:"Contribution link",type:"info"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/apple/swift-nio/pull/1692"},"https://github.com/apple/swift-nio/pull/1692"))),(0,s.kt)("admonition",{title:"Contribution Type",type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"This contribution is a new ",(0,s.kt)("strong",{parentName:"p"},"feature"),".")),(0,s.kt)("h2",{id:"introduction"},"Introduction"),(0,s.kt)("div",{className:"image-wrapper"},(0,s.kt)(i.ImageWrapper,{src:(0,a.Z)("img/swiftnio1692/cover.jpg"),width:"100%",alt:"SwiftNIO presentation",mdxType:"ImageWrapper"}),(0,s.kt)("em",null,"SwiftNIO presentation")),(0,s.kt)("h3",{id:"project"},"Project"),(0,s.kt)("p",null,"You can find the ",(0,s.kt)("a",{href:"/docs/projects/apple-swift-nio"},(0,s.kt)(u,{color:"#203666",mdxType:"Highlight"},"swiftNIO project presentation here")),"."),(0,s.kt)("h3",{id:"context"},"Context"),(0,s.kt)("h3",{id:"current-behavior"},"Current behavior"),(0,s.kt)("p",null,"Currently a user can create a ",(0,s.kt)("inlineCode",{parentName:"p"},"SocketAddress")," (represent a socket address to which we may want to connect) from a ",(0,s.kt)("strong",{parentName:"p"},"string representation")," of an IP address.   "),(0,s.kt)("p",null,"That would be good if we had helpers to create it from ",(0,s.kt)("strong",{parentName:"p"},"packed byte representation"),".   "),(0,s.kt)("admonition",{title:"Issue link",type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/apple/swift-nio/issues/1649"},"https://github.com/apple/swift-nio/issues/1649"))),(0,s.kt)("h2",{id:"implement-the-solution"},"Implement the solution"),(0,s.kt)("p",null,"To introduce the solution, we must know what an IP address (",(0,s.kt)("strong",{parentName:"p"},"I"),"nternet ",(0,s.kt)("strong",{parentName:"p"},"P"),"rotocol address) is.",(0,s.kt)("br",{parentName:"p"}),"\n","An IP address is a numerical label (an ",(0,s.kt)("strong",{parentName:"p"},"identifier"),") which is assigned to a device connected to a particular network (which uses IP to communicate)."),(0,s.kt)("p",null,"We must also know that an IP address can be in the form of ",(0,s.kt)("strong",{parentName:"p"},"IPv4")," or ",(0,s.kt)("strong",{parentName:"p"},"IPv6"),"."),(0,s.kt)("h3",{id:"ipv4"},"IPv4"),(0,s.kt)("p",null,"IPv4 is the first version of IP. It uses a ",(0,s.kt)("strong",{parentName:"p"},"32-bit")," address scheme and it is the ",(0,s.kt)("strong",{parentName:"p"},"most widely used")," IP version.",(0,s.kt)("br",{parentName:"p"}),"\n","It is expressed in ",(0,s.kt)("strong",{parentName:"p"},"dotted-decimal notation"),", with every bits represented by a number from 1 to 255.   "),(0,s.kt)("p",null,"For example: ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"168.212.226.204")),"."),(0,s.kt)("h3",{id:"ipv6"},"IPv6"),(0,s.kt)("p",null,"Conversely, IPv6 is the ",(0,s.kt)("strong",{parentName:"p"},"most recent")," version of IP. It uses a ",(0,s.kt)("strong",{parentName:"p"},"128-bit")," address scheme and it resolve some issues which are associated with IPv4.",(0,s.kt)("br",{parentName:"p"}),"\n","It is represented by eight sets of four hexadecimal digits separated by a colon.   "),(0,s.kt)("p",null,"For example: ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"fe80:0:0:0:0:0:0:5"))," which can be abbreviated as ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"fe80::5"))," in our test case bellow."),(0,s.kt)("p",null,"To recap, IP addresses have the following length:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"IP V4 address: ",(0,s.kt)("strong",{parentName:"li"},"4 bytes")),(0,s.kt)("li",{parentName:"ul"},"IP V6 address: ",(0,s.kt)("strong",{parentName:"li"},"16 bytes"))),(0,s.kt)("div",{className:"image-wrapper"},(0,s.kt)(i.ImageWrapper,{alt:"IP address logic",src:(0,a.Z)("img/swiftnio1692/main-logic.png"),mdxType:"ImageWrapper"}),(0,s.kt)("em",null,"IP address parsing")),(0,s.kt)("h3",{id:"create-socketaddress-from-packed-byte-representation"},"Create ",(0,s.kt)("inlineCode",{parentName:"h3"},"SocketAddress")," from packed byte representation"),(0,s.kt)("p",null,"As said above, the way we are going to differentiate an IPV6 address from IPV4 is thanks to their size."),(0,s.kt)("p",null,"We are first going to retrieve our IP Address which is a ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer"),"."),(0,s.kt)("h4",{id:"the-bytebufferstruct"},"The ",(0,s.kt)("inlineCode",{parentName:"h4"},"ByteBuffer"),"struct"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer")," is a specific SwiftNIO type of object, it stores contiguoulsy allocated raw bytes."),(0,s.kt)("p",null,"Here is a definition of the API that we will use:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"readableBytesView"),": a ",(0,s.kt)("strong",{parentName:"li"},"view")," into the readable bytes of the ByteBuffer"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"readableBytes"),": the ",(0,s.kt)("strong",{parentName:"li"},"number")," of bytes readable"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"copyBytes(at:to:length:)"),": ",(0,s.kt)("strong",{parentName:"li"},"copies length bytes")," starting at the ",(0,s.kt)("inlineCode",{parentName:"li"},"fromIndex")," to ",(0,s.kt)("inlineCode",{parentName:"li"},"toIndex"))),(0,s.kt)("p",null,"Now that we have defined what a ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer")," is, we are going to retrieve its ",(0,s.kt)("strong",{parentName:"p"},"size")," with ",(0,s.kt)("inlineCode",{parentName:"p"},"readableBytes")," and we will therefore be able to add our switch statement which will tell us if our ",(0,s.kt)("inlineCode",{parentName:"p"},"packedIpAddress")," is in the form of ",(0,s.kt)("strong",{parentName:"p"},"IPv6")," (a length of 16) or ",(0,s.kt)("strong",{parentName:"p"},"IPv4")," (a length of 4)."),(0,s.kt)("p",null,"Then inside our switch statement we will use our ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBufferView")," (thanks to ",(0,s.kt)("inlineCode",{parentName:"p"},"readableBytesView"),") to create a new ",(0,s.kt)("inlineCode",{parentName:"p"},"SocketAddress"),". "),(0,s.kt)("p",null,"Let's take a closer look at ",(0,s.kt)("inlineCode",{parentName:"p"},"sockaddr_in()")," (the behavior of ",(0,s.kt)("inlineCode",{parentName:"p"},"sockaddr_in6()")," is essentially the same):"),(0,s.kt)("div",{className:"image-wrapper"},(0,s.kt)(i.ImageWrapper,{alt:"IP address logic",src:(0,a.Z)("img/swiftnio1692/sockaddr-in.png"),mdxType:"ImageWrapper"}),(0,s.kt)("em",null,"sockaddr_in()")),(0,s.kt)("br",null),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Sources/NIO/SocketAddresses.swift"',title:'"Sources/NIO/SocketAddresses.swift"'},'/// Create a new `SocketAddress` for an IP address in ByteBuffer form.\n///\n/// - parameters:\n///     - packedIpAddress: The IP address, in ByteBuffer form.\n///     - port: The target port.\n/// - returns: the `SocketAddress` corresponding to this string and port combination.\n/// - throws: may throw `SocketAddressError.failedToParseIPByteBuffer` if the IP address cannot be parsed.\npublic init(packedIpAddress: ByteBuffer, port: Int) throws {\n    let packed = packedIpAddress.readableBytesView\n\n    switch packedIpAddress.readableBytes {\n    case 4:\n        var ipv4Addr = sockaddr_in()\n        ipv4Addr.sin_family = sa_family_t(AF_INET)\n        ipv4Addr.sin_port = in_port_t(port).bigEndian\n        withUnsafeMutableBytes(of: &ipv4Addr.sin_addr) { $0.copyBytes(from: packed) }\n        // Init our IPv4 address\n        self = .v4(.init(address: ipv4Addr, host: ""))\n    case 16:\n        var ipv6Addr = sockaddr_in6()\n        ipv6Addr.sin6_family = sa_family_t(AF_INET6)\n        ipv6Addr.sin6_port = in_port_t(port).bigEndian\n        withUnsafeMutableBytes(of: &ipv6Addr.sin6_addr) { $0.copyBytes(from: packed) }\n        // Init our IPv6 address\n        self = .v6(.init(address: ipv6Addr, host: ""))\n    default:\n        throw SocketAddressError.FailedToParseIPByteBuffer(address: packedIpAddress)\n    }\n}\n')),(0,s.kt)("h3",{id:"add-a-new-socketaddresserror"},"Add a new ",(0,s.kt)("inlineCode",{parentName:"h3"},"SocketAddressError")),(0,s.kt)("p",null,"This error is thrown when we can't parse the packed byte representattion."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Sources/NIO/SocketAddresses.swift"',title:'"Sources/NIO/SocketAddresses.swift"'},"extension SocketAddressError {\n    /// Unable to parse a given IP ByteBuffer\n    public struct FailedToParseIPByteBuffer: Error, Hashable {\n        public var address: ByteBuffer\n\n        public init(address: ByteBuffer) {\n            self.address = address\n        }\n    }\n}\n")),(0,s.kt)("h3",{id:"add-some-tests"},"Add some tests"),(0,s.kt)("p",null,"As said before, an ",(0,s.kt)("strong",{parentName:"p"},"IPv4")," adress contains 4 bytes, let's take ",(0,s.kt)("inlineCode",{parentName:"p"},"[0x7F, 0x00, 0x00, 0x01]")," which is the ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer")," representation of ",(0,s.kt)("inlineCode",{parentName:"p"},"127.0.0.1"),".   "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Tests/NIOTests/SocketAddressTest.swift"',title:'"Tests/NIOTests/SocketAddressTest.swift"'},'func testDescriptionWorksWithByteBufferIPv4IP() throws {\n    let IPv4: [UInt8] = [0x7F, 0x00, 0x00, 0x01]\n    let ipv4Address: ByteBuffer = ByteBuffer.init(bytes: IPv4)\n    let sa = try! SocketAddress(packedIpAddress: ipv4Address, port: 12345)\n    XCTAssertEqual("[IPv4]127.0.0.1:12345", sa.description)\n}\n')),(0,s.kt)("p",null,"An ",(0,s.kt)("strong",{parentName:"p"},"IPv6")," adress contains 16 bytes, let's take the ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer")," representation of ",(0,s.kt)("inlineCode",{parentName:"p"},"fe80::5"),".   "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Tests/NIOTests/SocketAddressTest.swift"',title:'"Tests/NIOTests/SocketAddressTest.swift"'},'func testDescriptionWorksWithByteBufferIPv6IP() throws {\n    let IPv6: [UInt8] = \n        [0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05]\n    let ipv6Address: ByteBuffer = ByteBuffer.init(bytes: IPv6)\n    let sa = try! SocketAddress(packedIpAddress: ipv6Address, port: 12345)\n    XCTAssertEqual("[IPv6]fe80::5:12345", sa.description)\n}\n')),(0,s.kt)("p",null,"If we provide a ",(0,s.kt)("inlineCode",{parentName:"p"},"ByteBuffer")," IP address with a wrong length we need to throw a new ",(0,s.kt)("inlineCode",{parentName:"p"},"FailedToParseIPByteBuffer")," error.   "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Tests/NIOTests/SocketAddressTest.swift"',title:'"Tests/NIOTests/SocketAddressTest.swift"'},'func testRejectsWrongIPByteBufferLength() {\n    let wrongIP: [UInt8] = [0x01, 0x7F, 0x00]\n    let ipAddress: ByteBuffer = ByteBuffer.init(bytes: wrongIP)\n    XCTAssertThrowsError(try SocketAddress(packedIpAddress: ipAddress, port: 12345)) { error in\n        switch error {\n        case is SocketAddressError.FailedToParseIPByteBuffer:\n            XCTAssertEqual(ipAddress, (error as! SocketAddressError.FailedToParseIPByteBuffer).address)\n        default:\n            XCTFail("unexpected error: \\(error)")\n        }\n    }\n}\n')),(0,s.kt)("h2",{id:"takeaway"},"Takeaway"),(0,s.kt)("h3",{id:"problems-encountered"},"Problems encountered"),(0,s.kt)("p",null,"At first I started implementing the new error in the existing enum ",(0,s.kt)("inlineCode",{parentName:"p"},"SocketAddressError"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'{10-11} title="Sources/NIO/SocketAddresses.swift"',"{10-11}":!0,title:'"Sources/NIO/SocketAddresses.swift"'},"public enum SocketAddressError: Error {\n    /// The host is unknown (could not be resolved).\n    case unknown(host: String, port: Int)\n    /// The requested `SocketAddress` is not supported.\n    case unsupported\n    /// The requested UDS path is too long.\n    case unixDomainSocketPathTooLong\n    /// Unable to parse a given IP string\n    case failedToParseIPString(String)\n    /// Unable to parse a given IP ByteBuffer\n    case failedToParseIPByteBuffer(ByteBuffer)\n")),(0,s.kt)("p",null,"But adding new cases to enumerations is a Semver major change.",(0,s.kt)("br",{parentName:"p"}),"\n","This is why I implemented the error as a ",(0,s.kt)("inlineCode",{parentName:"p"},"struct"),"."),(0,s.kt)("h3",{id:"what-did-i-learn-"},"What did I learn ?"),(0,s.kt)("p",null,"This contribution allowed me to learn more about ",(0,s.kt)("strong",{parentName:"p"},"IP addresses")," and ",(0,s.kt)("strong",{parentName:"p"},"packed bytes representation"),".",(0,s.kt)("br",{parentName:"p"}),"\n","Swift is not the language I usually use, so it allowed me to put into practice some concepts that I have learned in the past."))}m.isMDXComponent=!0},6395:function(e,t,r){r.r(t),r.d(t,{ImageWrapper:function(){return k},Merged:function(){return c},Open:function(){return m},Status:function(){return f},assets:function(){return p},contentTitle:function(){return d},default:function(){return g},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return u}});var n=r(3117),s=r(7294),a=r(3905),i=r(2879);const o={},d=void 0,l={unversionedId:"utils",id:"utils",title:"utils",description:"",source:"@site/docs/utils.md",sourceDirName:".",slug:"/utils",permalink:"/docs/utils",draft:!1,editUrl:"https://github.com/ayshiff/my-open-source-journey/docs/utils.md",tags:[],version:"current",frontMatter:{}},p={},u=[],c=e=>{let{date:t}=e;return(0,a.kt)("div",null,(0,a.kt)("div",{className:"merged"},(0,a.kt)("span",null,(0,a.kt)("svg",{height:"16",viewBox:"0 0 16 16",version:"1.1",width:"16",fill:"white","aria-hidden":"true",className:"status_svg"},(0,a.kt)("path",{fillRule:"evenodd",d:"M5 3.254V3.25v.005a.75.75 0 110-.005v.004zm.45 1.9a2.25 2.25 0 10-1.95.218v5.256a2.25 2.25 0 101.5 0V7.123A5.735 5.735 0 009.25 9h1.378a2.251 2.251 0 100-1.5H9.25a4.25 4.25 0 01-3.8-2.346zM12.75 9a.75.75 0 100-1.5.75.75 0 000 1.5zm-8.5 4.5a.75.75 0 100-1.5.75.75 0 000 1.5z"})),"Merged")),t||null)},k=e=>{let{src:t,alt:r,width:n}=e;const[o,d]=s.useState(!1);return(0,a.kt)("div",null,(0,a.kt)("div",{className:"image-zoom",onClick:()=>d(!0)},(0,a.kt)("img",{src:t,alt:r,width:n})),o&&(0,a.kt)(i.Z,{mainSrc:t,onCloseRequest:()=>d(!1),mdxType:"Lightbox"}))},m=e=>{let{date:t}=e;return(0,a.kt)("div",null,(0,a.kt)("div",{className:"open"},(0,a.kt)("span",null,(0,a.kt)("svg",{height:"16",viewBox:"0 0 16 16",version:"1.1",width:"16",fill:"white","aria-hidden":"true",className:"status_svg"},(0,a.kt)("path",{fillRule:"evenodd",d:"M7.177 3.073L9.573.677A.25.25 0 0110 .854v4.792a.25.25 0 01-.427.177L7.177 3.427a.25.25 0 010-.354zM3.75 2.5a.75.75 0 100 1.5.75.75 0 000-1.5zm-2.25.75a2.25 2.25 0 113 2.122v5.256a2.251 2.251 0 11-1.5 0V5.372A2.25 2.25 0 011.5 3.25zM11 2.5h-1V4h1a1 1 0 011 1v5.628a2.251 2.251 0 101.5 0V5A2.5 2.5 0 0011 2.5zm1 10.25a.75.75 0 111.5 0 .75.75 0 01-1.5 0zM3.75 12a.75.75 0 100 1.5.75.75 0 000-1.5z"})),"Open")),t||null)},f=e=>{let{url:t}=e;const[r,n]=s.useState(null);return s.useEffect((()=>{let e=!0;return fetch(t).then((e=>e.json())).then((t=>{e&&n(t.merged)})),()=>{e=!1}}),[]),null===r?(0,a.kt)("div",null):!0===r?(0,a.kt)(c,{mdxType:"Merged"}):(0,a.kt)(m,{mdxType:"Open"})},h={toc:u,Merged:c,ImageWrapper:k,Open:m,Status:f};function g(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}))}g.isMDXComponent=!0}}]);